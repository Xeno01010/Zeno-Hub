local function chooseNewFocusedBall()
     local balls = ballsFolder:GetChildren()
     for _, ball in ipairs(balls) do
         if ball:GetAttribute("realBall") ~= nil and ball:GetAttribute("realBall") == true then
             focusedBall = ball
             print(focusedBall.Name)
             break
         elseif ball:GetAttribute("target") ~= nil then
             focusedBall = ball
             print(focusedBall.Name)
             break
         end
     end
     
     if focusedBall == nil then
         print("Debug: Could not find a ball that's the realBall or has a target.")
         wait(1)
         chooseNewFocusedBall()
     end
     return focusedBall
 end
 
 local function getDynamicThreshold(ballVelocityMagnitude)
     if ballVelocityMagnitude > 60 then
         return math.max(0.20, BASE_THRESHOLD - (ballVelocityMagnitude * VELOCITY_SCALING_FACTOR_FAST))
     else
         return math.min(0.01, BASE_THRESHOLD + (ballVelocityMagnitude * VELOCITY_SCALING_FACTOR_SLOW))
     end
 end
 
 local function timeUntilImpact(ballVelocity, distanceToPlayer, playerVelocity)
     if not character then return end
     local directionToPlayer = (character.HumanoidRootPart.Position - focusedBall.Position).Unit
     local velocityTowardsPlayer = ballVelocity:Dot(directionToPlayer) - playerVelocity:Dot(directionToPlayer)
     
     if velocityTowardsPlayer <= 0 then
         return math.huge
     end
     
     return (distanceToPlayer - sliderValue) / velocityTowardsPlayer
 end
 
 local function updateDistanceVisualizer()
     local charPos = character and character.PrimaryPart and character.PrimaryPart.Position
     if charPos and focusedBall then
         if distanceVisualizer then
             distanceVisualizer:Destroy()
         end
 
         local timeToImpactValue = timeUntilImpact(focusedBall.Velocity, (focusedBall.Position - charPos).Magnitude, character.PrimaryPart.Velocity)
         local ballFuturePosition = focusedBall.Position + focusedBall.Velocity * timeToImpactValue
 
         distanceVisualizer = Instance.new("Part")
         distanceVisualizer.Size = Vector3.new(1, 1, 1)
         distanceVisualizer.Anchored = true
         distanceVisualizer.CanCollide = false
         distanceVisualizer.Position = ballFuturePosition
         distanceVisualizer.Parent = workspace    
     end
 end
 
 local function checkIfTarget()
     for _, v in pairs(ballsFolder:GetChildren()) do
         if v:IsA("Part") and v.BrickColor == BrickColor.new("Really red") then 
             print("Ball is targetting player.")
             return true 
         end 
     end 
     return false
 end
 
 local function isCooldownInEffect(uigradient)
     return uigradient.Offset.Y < 0.5
 end
 
 
 local function checkBallDistance()
     if not character or not checkIfTarget() then return end
 
     local charPos = character.PrimaryPart.Position
     local charVel = character.PrimaryPart.Velocity
 
     if focusedBall and not focusedBall.Parent then
         print("Focused ball lost parent. Choosing a new focused ball.")
         chooseNewFocusedBall()
     end
     if not focusedBall then 
         print("No focused ball.")
         chooseNewFocusedBall()
     end
 
     local ball = focusedBall
     local distanceToPlayer = (ball.Position - charPos).Magnitude
     local ballVelocityTowardsPlayer = ball.Velocity:Dot((charPos - ball.Position).Unit)
     
     if distanceToPlayer < 15 then
         parryButtonPress:Fire()
         task.wait()
     end
 
     if timeUntilImpact(ball.Velocity, distanceToPlayer, charVel) < getDynamicThreshold(ballVelocityTowardsPlayer) then
         if (character.Abilities["Raging Deflection"].Enabled or character.Abilities["Rapture"].Enabled) and UseRage == true then
             if not isCooldownInEffect(uigrad2) then
                 abilityButtonPress:Fire()
             end
 
             if isCooldownInEffect(uigrad2) and not isCooldownInEffect(uigrad1) then
                 parryButtonPress:Fire()
                 if notifyparried == true then
                     notify("Auto Parry", "Manually Parried Ball (Ability on CD)", 0.3)
                 end
             end
 
         elseif not isCooldownInEffect(uigrad1) then
             print(isCooldownInEffect(uigrad1))
             parryButtonPress:Fire()
             if notifyparried == true then
                 notify("Auto Parry", "Automatically Parried Ball", 0.3)
             end
             task.wait(0.3)
         end
     end
 end
 
 
 local function autoParryCoroutine()
     while isRunning do
         checkBallDistance()
         updateDistanceVisualizer()
         task.wait()
     end
 end
 
 
 
 localPlayer.CharacterAdded:Connect(function(newCharacter)
     character = newCharacter
     chooseNewFocusedBall()
     updateDistanceVisualizer()
 end)
 
 localPlayer.CharacterRemoving:Connect(function()
     if distanceVisualizer then
         distanceVisualizer:Destroy()
         distanceVisualizer = nil
     end
 end)
 
 
 
 local function startAutoParry()
     print("Script successfully ran.")
     
     chooseNewFocusedBall()
     
     isRunning = true
     local co = coroutine.create(autoParryCoroutine)
     coroutine.resume(co)
 end
 
 local function stopAutoParry()
     isRunning = false
 end
